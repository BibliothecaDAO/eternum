use s1_eternum::alias::ID;
use s1_eternum::models::hyperstructure::ConstructionAccess;
use starknet::ContractAddress;

/// # Hyperstructure Systems Interface
///
/// This interface defines the core functions for managing hyperstructures in the Eternum game.
/// Hyperstructures are large-scale collaborative buildings that players can contribute resources
/// to, earn points from, and share ownership of through a shareholder system.
///
/// ## Key Formulas
///
/// * Construction Points Calculation:
///   `generated_construction_points
///     = (contributed_resource_amount_contributed / total_resource_amount) *
///     total_points_generated_for_that_particular_resource's_completion`
///
///
/// * Share Points Generation:
///   `generated_share_points = (shareholder_percentage / 100) * time_elapsed * points_per_second `
///
#[starknet::interface]
trait IHyperstructureSystems<T> {
    /// Initializes a hyperstructure, making it ready to receive contributions.
    ///
    /// This function must be called by the hyperstructure owner before any contributions can be
    /// made.
    /// It spends a specified amount of Earthen Shards from the hyperstructure's balance to activate
    /// it.
    ///
    /// # Arguments
    /// * `hyperstructure_id` - The ID of the hyperstructure to initialize
    ///
    /// # Requirements
    /// * Caller must own the structure
    /// * Structure must be of hyperstructure category
    /// * Hyperstructure must not already be initialized
    /// * Hyperstructure must have sufficient Earthen Shards for initialization
    ///
    /// # Effects
    /// * Sets the hyperstructure as initialized
    /// * Calculates and records total resources needed for construction
    /// * Spends Earthen Shards from the hyperstructure's balance
    /// * Triggers an achievement for hyperstructure creation
    fn initialize(ref self: T, hyperstructure_id: ID);

    /// Contributes resources to a hyperstructure's construction.
    ///
    /// Players can contribute multiple resource types in a single transaction. Resources are taken
    /// from the specified structure and added to the hyperstructure's construction progress. The
    /// player earns construction points proportional to their contribution.
    ///
    /// # Arguments
    /// * `hyperstructure_id` - The ID of the hyperstructure to contribute to
    /// * `from_structure_id` - The ID of the structure providing the resources
    /// * `contribution` - A list of (resource_type, amount) pairs to contribute
    ///
    /// # Requirements
    /// * Caller must own the contributing structure
    /// * Hyperstructure must be initialized and not completed
    /// * Contributor must have access to the hyperstructure (based on access control settings)
    /// * Contributed amounts must be positive and not exceed remaining requirements
    /// * Contributed amounts must be multiples of RESOURCE_PRECISION
    ///
    /// # Effects
    /// * Burns resources from the contributing structure
    /// * Updates hyperstructure construction progress
    /// * Awards unregistered construction points to the contributor using the formula:
    ///   `points = (resource_amount / RESOURCE_PRECISION) * resource_point_value / (needed_amount /
    ///   RESOURCE_PRECISION)`
    /// * Marks hyperstructure as completed if all requirements are met
    /// * Automatically sets up initial shareholding for the hyperstructure owner when completed
    /// * Triggers achievement for hyperstructure contribution
    fn contribute(ref self: T, hyperstructure_id: ID, from_structure_id: ID, contribution: Span<(u8, u128)>);

    /// Allocates shares of a completed hyperstructure to a list of shareholders.
    ///
    /// Shares determine what percentage of points generated by the hyperstructure each player
    /// receives.
    /// The hyperstructure owner can redistribute shares at any time, which takes effect
    /// immediately.
    ///
    /// # Arguments
    /// * `hyperstructure_id` - The ID of the hyperstructure
    /// * `shareholders` - A list of (address, percentage) pairs, where percentage is in basis
    /// points (0-10000)
    ///
    /// # Requirements
    /// * Caller must own the hyperstructure
    /// * Hyperstructure must be initialized and completed
    /// * Total percentage allocated must equal exactly 100% (10000 basis points)
    /// * Maximum of 20 shareholders allowed
    /// * All shareholder addresses must be non-zero
    ///
    /// # Effects
    /// * Claims all pending share points for current shareholders before reallocation
    /// * Sets new shareholders with specified percentages
    /// * Updates the timestamp for point calculation
    fn allocate_shares(ref self: T, hyperstructure_id: ID, shareholders: Span<(ContractAddress, u16)>);

    /// Updates the construction access control for a hyperstructure.
    ///
    /// The owner can control who is allowed to contribute resources to the hyperstructure:
    /// - Public: Anyone can contribute
    /// - GuildOnly: Only members of the owner's guild can contribute
    /// - OwnerOnly: Only the owner can contribute
    ///
    /// # Arguments
    /// * `hyperstructure_id` - The ID of the hyperstructure
    /// * `access` - The new access control setting
    ///
    /// # Requirements
    /// * Caller must own the hyperstructure
    /// * Hyperstructure must be initialized
    /// * If setting GuildOnly access, the owner must be a member of a guild
    ///
    /// # Effects
    /// * Updates the hyperstructure's access control setting
    fn update_construction_access(ref self: T, hyperstructure_id: ID, access: ConstructionAccess);


    /// Claims share points earned by shareholders of completed hyperstructures.
    ///
    /// This function calculates and distributes points generated by hyperstructures to their
    /// shareholders based on time elapsed and shareholding percentages.
    ///
    /// # Arguments
    /// * `hyperstructure_ids` - List of hyperstructure IDs to claim points from
    ///
    /// # Requirements
    /// * Can only be called during the season's main game and before point registration grace
    /// period ends * Hyperstructures must be initialized and completed
    /// * Some time must have elapsed since the last claim or share allocation
    ///
    /// # Effects
    /// * Calculates points generated for each shareholder using the formula:
    ///   `points = time_elapsed * points_per_second * shareholder_percentage / 100%`
    /// * Adds points to shareholders' registered points
    /// * Updates the season's total registered points
    /// * Resets the hyperstructure's share start timestamp
    fn claim_share_points(ref self: T, hyperstructure_ids: Span<ID>);
}


#[dojo::contract]
pub mod hyperstructure_systems {
    use core::num::traits::Bounded;
    use core::num::traits::zero::Zero;
    use dojo::model::ModelStorage;

    use dojo::world::WorldStorage;
    use s1_eternum::constants::{DEFAULT_NS, WORLD_CONFIG_ID};
    use s1_eternum::models::map::Tile;
    use s1_eternum::models::owner::OwnerAddressImpl;
    use s1_eternum::models::resource::resource::{
        ResourceWeightImpl, SingleResource, SingleResourceImpl, SingleResourceStoreImpl, WeightStoreImpl,
    };
    use s1_eternum::models::weight::{Weight, WeightImpl};
    use s1_eternum::systems::utils::map::IMapImpl;
    use s1_eternum::systems::utils::structure::iStructureImpl;
    use s1_eternum::utils::random::VRFImpl;
    use s1_eternum::{
        alias::ID, constants::{RESOURCE_PRECISION, ResourceTypes},
        models::{
            config::{HyperstructureConfig, HyperstructureCostConfig, SeasonConfigImpl, WorldConfigUtilImpl},
            guild::{GuildMember},
            hyperstructure::{
                ConstructionAccess, Hyperstructure, HyperstructureConstructionAccessImpl, HyperstructureGlobals,
                HyperstructureRequirementsImpl, HyperstructureShareholders, PlayerRegisteredPoints,
            },
            owner::{OwnerAddressTrait}, resource::resource::{}, season::{SeasonPrize},
            structure::{StructureBase, StructureBaseStoreImpl, StructureCategory, StructureOwnerStoreImpl},
        },
        utils::achievements::index::{AchievementTrait, Tasks}, utils::math::PercentageValueImpl,
    };
    use starknet::{ContractAddress};


    #[abi(embed_v0)]
    impl HyperstructureSystemsImpl of super::IHyperstructureSystems<ContractState> {
        fn initialize(ref self: ContractState, hyperstructure_id: ID) {
            let mut world: WorldStorage = self.world(DEFAULT_NS());
            SeasonConfigImpl::get(world).assert_started_and_not_over();

            // ensure caller owns the structure
            let mut structure_owner: ContractAddress = StructureOwnerStoreImpl::retrieve(ref world, hyperstructure_id);
            structure_owner.assert_caller_owner();

            // ensure structure is a hyperstructure
            let structure: StructureBase = StructureBaseStoreImpl::retrieve(ref world, hyperstructure_id);
            assert!(structure.category == StructureCategory::Hyperstructure.into(), "not a hyperstructure");

            // ensure hyperstructure has not been initialized
            let mut hyperstructure: Hyperstructure = world.read_model(hyperstructure_id);
            assert!(hyperstructure.initialized == false, "hyperstructure is already initialized");

            // spend shards from hyperstructure's balance
            let hyperstructure_config: HyperstructureConfig = WorldConfigUtilImpl::get_member(
                world, selector!("hyperstructure_config"),
            );
            let required_shards_amount = hyperstructure_config.initialize_shards_amount;
            let mut hyperstructure_weight: Weight = WeightStoreImpl::retrieve(ref world, hyperstructure_id);
            let shards_resource_weight_grams: u128 = ResourceWeightImpl::grams(ref world, ResourceTypes::EARTHEN_SHARD);
            let mut hyperstructure_shard_resource: SingleResource = SingleResourceStoreImpl::retrieve(
                ref world,
                hyperstructure_id,
                ResourceTypes::EARTHEN_SHARD,
                ref hyperstructure_weight,
                shards_resource_weight_grams,
                true,
            );

            // spend required shards amount for initialization
            hyperstructure_shard_resource
                .spend(required_shards_amount, ref hyperstructure_weight, shards_resource_weight_grams);
            hyperstructure_shard_resource.store(ref world);
            hyperstructure_weight.store(ref world, hyperstructure_id);

            // set total needed amount
            let mut construction_total_needed_amount = 0;
            let hyperstructure_cost_config: HyperstructureCostConfig = WorldConfigUtilImpl::get_member(
                world, selector!("hyperstructure_cost_config"),
            );
            for i in 0..hyperstructure_cost_config.construction_resources_ids.len() {
                let resource_type = *hyperstructure_cost_config.construction_resources_ids.at(i);
                construction_total_needed_amount +=
                    HyperstructureRequirementsImpl::get_amount_needed(ref world, hyperstructure, resource_type);
            };
            HyperstructureRequirementsImpl::initialize(ref world, hyperstructure_id);
            HyperstructureRequirementsImpl::write_needed_resource_total(
                ref world, hyperstructure_id, construction_total_needed_amount,
            );

            // set hyperstructure as initialized
            hyperstructure.initialized = true;
            world.write_model(@hyperstructure);

            // update structure tile
            let mut hyperstructure_tile: Tile = world.read_model((structure.coord_x, structure.coord_y));
            let hyperstructure_tile_occupier = IMapImpl::get_hyperstructure_occupier(1);
            IMapImpl::occupy(ref world, ref hyperstructure_tile, hyperstructure_tile_occupier, hyperstructure_id);
        }

        fn contribute(
            ref self: ContractState, hyperstructure_id: ID, from_structure_id: ID, contribution: Span<(u8, u128)>,
        ) {
            let mut world: WorldStorage = self.world(DEFAULT_NS());
            SeasonConfigImpl::get(world).assert_started_and_not_over();

            // ensure caller structure is owned by caller
            let from_structure_owner: ContractAddress = StructureOwnerStoreImpl::retrieve(ref world, from_structure_id);
            from_structure_owner.assert_caller_owner();

            // ensure structure is a hyperstructure
            let structure_base: StructureBase = StructureBaseStoreImpl::retrieve(ref world, hyperstructure_id);
            assert!(structure_base.category == StructureCategory::Hyperstructure.into(), "not a hyperstructure");

            // ensure hyperstructure is initialized and not completed
            let mut hyperstructure: Hyperstructure = world.read_model(hyperstructure_id);
            assert!(hyperstructure.initialized, "hyperstructure has not been initialized");
            assert!(hyperstructure.completed == false, "hyperstructure has been completed");

            // ensure contributor has access to contribute to the hyperstructure
            let hyperstructure_owner: ContractAddress = StructureOwnerStoreImpl::retrieve(ref world, hyperstructure_id);
            hyperstructure.assert_caller_construction_access(ref world, hyperstructure_owner);

            // contribute to hyperstructure
            let mut total_resource_amount_contributed_by_structure = 0;
            let mut from_structure_weight: Weight = WeightStoreImpl::retrieve(ref world, from_structure_id);
            for (resource_type, resource_amount) in contribution {
                let (resource_type, resource_amount) = (*resource_type, *resource_amount);
                assert!(resource_amount.is_non_zero(), "contributed amount must be greater than zero");

                // ensure that resource amount does not exceed max contributable
                let current_contributed_amount = HyperstructureRequirementsImpl::read_current_amount(
                    ref world, hyperstructure_id, resource_type,
                );
                let needed_contribution_amount = HyperstructureRequirementsImpl::get_amount_needed(
                    ref world, hyperstructure, resource_type,
                );
                let max_contributable_amount = needed_contribution_amount - current_contributed_amount;
                assert!(
                    max_contributable_amount.is_non_zero(), "contribution for resource ({})is complete", resource_type,
                );

                // ensure resource amount is a multiplier of RESOURCE_PRECISION
                let resource_amount = core::cmp::min(max_contributable_amount, resource_amount);
                assert!(resource_amount % RESOURCE_PRECISION == 0, "amount not multiplier of RESOURCE_PRECISION");

                // burn caller structure's resource
                let resource_weight_grams: u128 = ResourceWeightImpl::grams(ref world, resource_type);
                let mut from_structure_resource: SingleResource = SingleResourceStoreImpl::retrieve(
                    ref world, from_structure_id, resource_type, ref from_structure_weight, resource_weight_grams, true,
                );
                from_structure_resource.spend(resource_amount, ref from_structure_weight, resource_weight_grams);
                from_structure_resource.store(ref world);

                // update current contributable amount
                HyperstructureRequirementsImpl::write_current_amount(
                    ref world, hyperstructure_id, resource_type, current_contributed_amount + resource_amount,
                );
                total_resource_amount_contributed_by_structure += resource_amount;

                // add points to player's registered points and update global total registered
                // points
                let generated_points = (resource_amount / RESOURCE_PRECISION)
                    * HyperstructureRequirementsImpl::get_resource_points(ref world, resource_type)
                    / (needed_contribution_amount / RESOURCE_PRECISION);

                let mut player_points: PlayerRegisteredPoints = world.read_model(from_structure_owner);
                let mut season_prize: SeasonPrize = world.read_model(WORLD_CONFIG_ID);
                player_points.registered_points += generated_points;
                season_prize.total_registered_points += generated_points;

                world.write_model(@player_points);
                world.write_model(@season_prize);
            };

            // update structure weight
            from_structure_weight.store(ref world, from_structure_id);

            // update resource amount contributed by all
            let total_resource_amount_contributed_by_all = HyperstructureRequirementsImpl::read_current_resource_total(
                ref world, hyperstructure_id,
            );
            let new_total_resource_amount_contributed_by_all = (total_resource_amount_contributed_by_all
                + total_resource_amount_contributed_by_structure);
            HyperstructureRequirementsImpl::write_current_resource_total(
                ref world, hyperstructure_id, new_total_resource_amount_contributed_by_all,
            );
            let needed_total_resource_amount_contributed_by_all =
                HyperstructureRequirementsImpl::read_needed_resource_total(
                ref world, hyperstructure_id,
            );

            // mark hyperstructure as completed, if completed
            if new_total_resource_amount_contributed_by_all == needed_total_resource_amount_contributed_by_all {
                hyperstructure.completed = true;
                world.write_model(@hyperstructure);

                // increase hyperstructure completed count
                let mut hyperstructure_globals: HyperstructureGlobals = world.read_model(WORLD_CONFIG_ID);
                hyperstructure_globals.completed_count += 1;
                world.write_model(@hyperstructure_globals);

                // make hyperstructure owner start receiving points
                world
                    .write_model(
                        @HyperstructureShareholders {
                            hyperstructure_id,
                            start_at: starknet::get_block_timestamp(),
                            shareholders: array![
                                (hyperstructure_owner, PercentageValueImpl::_100().try_into().unwrap()),
                            ]
                                .span(),
                        },
                    );

                // update structure tile
                let mut hyperstructure_tile: Tile = world.read_model((structure_base.coord_x, structure_base.coord_y));
                let hyperstructure_tile_occupier = IMapImpl::get_hyperstructure_occupier(2);
                IMapImpl::occupy(ref world, ref hyperstructure_tile, hyperstructure_tile_occupier, hyperstructure_id);
            }

            // grant hyperstructure contribution achievement
            let contribution_try_y32: u128 = total_resource_amount_contributed_by_structure / RESOURCE_PRECISION;
            let max_u32: u32 = Bounded::MAX;
            if contribution_try_y32 > max_u32.into() {
                panic!("Contribution is too large. try contributing in batches of <= 4 billion resources");
            }
            let contribution_u32: u32 = contribution_try_y32.try_into().unwrap();
            AchievementTrait::progress(
                world,
                from_structure_owner.into(),
                Tasks::CONTRIBUTE_HYPERSTRUCTURE,
                contribution_u32,
                starknet::get_block_timestamp(),
            );
        }

        fn allocate_shares(ref self: ContractState, hyperstructure_id: ID, shareholders: Span<(ContractAddress, u16)>) {
            let mut world: WorldStorage = self.world(DEFAULT_NS());
            SeasonConfigImpl::get(world).assert_started_and_not_over();

            // todo: test gas for 20 shareholders
            // ensure there are never more than 20 shareholders at a time
            assert!(shareholders.len() <= 20, "too many shareholders, maximum of 20");

            // ensure the structure is owned by caller
            let structure_owner: ContractAddress = StructureOwnerStoreImpl::retrieve(ref world, hyperstructure_id);
            structure_owner.assert_caller_owner();

            // ensure the structure is a hyperstructure
            let structure: StructureBase = StructureBaseStoreImpl::retrieve(ref world, hyperstructure_id);
            assert!(structure.category == StructureCategory::Hyperstructure.into(), "not a hyperstructure");

            // ensure hyperstructure is initialized and completed
            let mut hyperstructure: Hyperstructure = world.read_model(hyperstructure_id);
            assert!(hyperstructure.initialized, "hyperstructure has not been initialized");
            assert!(hyperstructure.completed, "hyperstructure has not been completed");

            // ensure the allocated percentage does not exceed 100%
            let mut allocated_percentage: u16 = 0;
            for i in 0..shareholders.len() {
                let (address, percentage) = *shareholders.at(i);
                assert!(address.is_non_zero(), "zero address shareholders");
                allocated_percentage += percentage;

                // ensure the min percentage is 1% to ensure that no one's
                // generated points round out to zero
                assert!(percentage.into() >= PercentageValueImpl::_1(), "minimum percentage is 1%");

                // initialize the player registered points model in the indexer
                // if not present
                let player_points_initializer: PlayerRegisteredPoints = world.read_model(address);
                world.write_model(@player_points_initializer);
            };
            assert!(
                allocated_percentage.into() == PercentageValueImpl::_100(),
                "total allocated percentage must be {}",
                PercentageValueImpl::_100(),
            );

            // todo check no adverse effect of duplicated shareholder address

            // claim points for current shareholders
            self.claim_share_points(array![hyperstructure_id].span());

            let hyperstructure_shareholders = HyperstructureShareholders {
                hyperstructure_id, start_at: starknet::get_block_timestamp(), shareholders,
            };
            world.write_model(@hyperstructure_shareholders);
        }

        // claim share points for any player
        fn claim_share_points(ref self: ContractState, hyperstructure_ids: Span<ID>) {
            let mut world: WorldStorage = self.world(DEFAULT_NS());

            // ensure function can only be called before point registration grace ends
            let season_config = SeasonConfigImpl::get(world);
            season_config.assert_main_game_started_and_point_registration_grace_not_elapsed();

            let mut season_prize: SeasonPrize = world.read_model(WORLD_CONFIG_ID);

            for hyperstructure_id in hyperstructure_ids {
                // ensure hyperstructure is initialized and completed
                let hyperstructure_id = *hyperstructure_id;
                let mut hyperstructure: Hyperstructure = world.read_model(hyperstructure_id);
                assert!(hyperstructure.initialized, "hyperstructure has not been initialized");
                assert!(hyperstructure.completed, "hyperstructure has not been completed");

                let mut hyperstructure_shareholders: HyperstructureShareholders = world.read_model(hyperstructure_id);
                let ts = starknet::get_block_timestamp();
                let time_elapsed = if season_config.has_ended() {
                    season_config.end_at - hyperstructure_shareholders.start_at
                } else {
                    ts - hyperstructure_shareholders.start_at
                };
                assert!(time_elapsed.is_non_zero(), "zero time elapsed");

                let current_shareholders = hyperstructure_shareholders.shareholders;
                let hyperstructure_config: HyperstructureConfig = WorldConfigUtilImpl::get_member(
                    world, selector!("hyperstructure_config"),
                );
                for i in 0..current_shareholders.len() {
                    let (shareholder_address, shareholder_percentage) = current_shareholders.at(i);
                    if shareholder_address.is_non_zero() {
                        let mut shareholder_points: PlayerRegisteredPoints = world.read_model(*shareholder_address);
                        let generated_points: u256 = time_elapsed.into()
                            * hyperstructure_config.points_per_second.into()
                            * (*shareholder_percentage).into()
                            / PercentageValueImpl::_100().into();
                        let generated_points: u128 = generated_points.try_into().unwrap();
                        shareholder_points.registered_points += generated_points;
                        world.write_model(@shareholder_points);

                        // increase global total registered points
                        season_prize.total_registered_points += generated_points;
                    }
                };

                // update global total registered points
                world.write_model(@season_prize);

                // reset hyperstructure shareholding start time
                let mut start_at = ts;
                if season_config.has_ended() {
                    start_at = season_config.end_at
                };
                hyperstructure_shareholders.start_at = start_at;
                world.write_model(@hyperstructure_shareholders);
            }
        }

        fn update_construction_access(ref self: ContractState, hyperstructure_id: ID, access: ConstructionAccess) {
            let mut world: WorldStorage = self.world(DEFAULT_NS());
            SeasonConfigImpl::get(world).assert_started_and_not_over();

            // ensure the structure is a hyperstructure
            let structure_owner: ContractAddress = StructureOwnerStoreImpl::retrieve(ref world, hyperstructure_id);
            structure_owner.assert_caller_owner();

            let structure_base: StructureBase = StructureBaseStoreImpl::retrieve(ref world, hyperstructure_id);
            assert!(structure_base.category == StructureCategory::Hyperstructure.into(), "not a hyperstructure");

            // ensure hyperstructure is initialized
            let mut hyperstructure: Hyperstructure = world.read_model(hyperstructure_id);
            assert!(hyperstructure.initialized, "hyperstructure has not been initialized");

            // ensure owner has a guild if set to guild only
            if (access == ConstructionAccess::GuildOnly) {
                let structure_owner_guild_member: GuildMember = world.read_model(structure_owner);
                assert!(structure_owner_guild_member.guild_id.is_non_zero(), "you are not a member of any guild");
            }

            // update construction access
            hyperstructure.access = access;
            world.write_model(@hyperstructure);
        }
    }
}
