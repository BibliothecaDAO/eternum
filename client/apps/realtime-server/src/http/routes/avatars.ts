import { randomUUID } from "crypto";
import { and, desc, eq, or, sql } from "drizzle-orm";
import { Hono } from "hono";

import { db } from "../../db/client";
import { avatarGenerationLogs, playerProfiles } from "../../db/schema/profiles";
import { generateAvatar, getGenerationStatus } from "../../services/fal-client";
import type { AppEnv } from "../middleware/auth";
import { requirePlayerSession } from "../middleware/auth";
import { avatarRateLimit, incrementRateLimit } from "../middleware/rate-limit";

export const avatarRoutes = new Hono<AppEnv>();

const GENERATION_WINDOW_MS = 7 * 24 * 60 * 60 * 1000;

avatarRoutes.post("/generate", requirePlayerSession, avatarRateLimit, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const body = await c.req.json().catch(() => ({}));
  const { prompt, style } = body;

  if (!prompt || typeof prompt !== "string" || prompt.trim().length === 0) {
    return c.json({ error: "Prompt is required" }, 400);
  }

  if (prompt.length > 500) {
    return c.json({ error: "Prompt is too long (max 500 characters)" }, 400);
  }

  const sanitizedPrompt = prompt.trim();

  const logId = randomUUID();

  try {
    await db.insert(avatarGenerationLogs).values({
      id: logId,
      cartridgeUsername: player.displayName,
      prompt: sanitizedPrompt,
      status: "pending",
      falJobId: null,
      errorMessage: null,
      imageUrl: null,
      imageUrls: [],
    });

    const result = await generateAvatar({
      prompt: sanitizedPrompt,
      style: style || undefined,
    });

    const primaryImageUrl = result.imageUrls[0];
    if (!primaryImageUrl) {
      throw new Error("No images generated by Fal AI");
    }

    await db
      .update(avatarGenerationLogs)
      .set({
        status: "completed",
        falJobId: result.jobId,
        imageUrl: primaryImageUrl,
        imageUrls: result.imageUrls,
      })
      .where(eq(avatarGenerationLogs.id, logId));

    const now = new Date();
    const generationCutoff = new Date(now.getTime() - GENERATION_WINDOW_MS);
    const [profile] = await db
      .insert(playerProfiles)
      .values({
        cartridgeUsername: player.displayName,
        playerAddress: player.playerId,
        avatarUrl: primaryImageUrl,
        avatarGenerationPrompt: sanitizedPrompt,
        falImageId: result.jobId,
        generationCount: 1,
        lastGenerationAt: now,
        createdAt: now,
        updatedAt: now,
      })
      .onConflictDoUpdate({
        target: playerProfiles.cartridgeUsername,
        set: {
          avatarUrl: primaryImageUrl,
          avatarGenerationPrompt: sanitizedPrompt,
          falImageId: result.jobId,
          generationCount: sql`CASE WHEN ${playerProfiles.lastGenerationAt} IS NULL OR ${playerProfiles.lastGenerationAt} < ${generationCutoff} THEN 1 ELSE ${playerProfiles.generationCount} + 1 END`,
          lastGenerationAt: now,
          updatedAt: now,
        },
      })
      .returning();

    incrementRateLimit(player.displayName);

    return c.json(
      {
        success: true,
        jobId: result.jobId,
        imageUrls: result.imageUrls,
        profile,
      },
      201,
    );
  } catch (error) {
    console.error("Failed to generate avatar:", error);

    await db
      .update(avatarGenerationLogs)
      .set({
        status: "failed",
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      })
      .where(eq(avatarGenerationLogs.id, logId));

    return c.json({ error: "Failed to generate avatar. Please try again later." }, 500);
  }
});

avatarRoutes.get("/status/:jobId", requirePlayerSession, async (c) => {
  const jobId = c.req.param("jobId");

  if (!jobId) {
    return c.json({ error: "Job ID is required" }, 400);
  }

  try {
    const status = await getGenerationStatus(jobId);
    return c.json(status);
  } catch (error) {
    console.error("Failed to check generation status:", error);
    return c.json({ error: "Failed to check generation status" }, 500);
  }
});

avatarRoutes.get("/profile/:username", async (c) => {
  const username = c.req.param("username");

  if (!username) {
    return c.json({ error: "Username is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(eq(playerProfiles.cartridgeUsername, username))
      .limit(1);

    if (!profile) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.get("/profile-by-address/:address", async (c) => {
  const address = c.req.param("address");

  if (!address) {
    return c.json({ error: "Address is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(eq(playerProfiles.playerAddress, address))
      .limit(1);

    if (!profile) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.get("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(eq(playerProfiles.cartridgeUsername, player.displayName))
      .limit(1);

    if (!profile) {
      return c.json(
        {
          cartridgeUsername: player.displayName,
          playerAddress: player.playerId,
          avatarUrl: null,
          createdAt: null,
        },
        200,
      );
    }

    const now = Date.now();
    const lastGenerationAt = profile.lastGenerationAt;
    const generationCount =
      lastGenerationAt && now - lastGenerationAt.getTime() < GENERATION_WINDOW_MS ? profile.generationCount : 0;

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
      generationCount,
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.delete("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  try {
    const { rowCount } = await db
      .update(playerProfiles)
      .set({
        avatarUrl: null,
        updatedAt: new Date(),
      })
      .where(eq(playerProfiles.cartridgeUsername, player.displayName));

    if (rowCount === 0) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.body(null, 204);
  } catch (error) {
    console.error("Failed to delete avatar:", error);
    return c.json({ error: "Failed to delete avatar" }, 500);
  }
});

avatarRoutes.patch("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const body = await c.req.json().catch(() => ({}));
  const { imageUrl } = body;

  if (!imageUrl || typeof imageUrl !== "string") {
    return c.json({ error: "imageUrl is required" }, 400);
  }

  const [matchingLog] = await db
    .select({ id: avatarGenerationLogs.id })
    .from(avatarGenerationLogs)
    .where(
      and(
        eq(avatarGenerationLogs.cartridgeUsername, player.displayName),
        or(
          eq(avatarGenerationLogs.imageUrl, imageUrl),
          sql`${avatarGenerationLogs.imageUrls} @> ${JSON.stringify([imageUrl])}::jsonb`,
        ),
      ),
    )
    .limit(1);

  if (!matchingLog) {
    return c.json({ error: "Avatar image not found for this user" }, 404);
  }

  const [profile] = await db
    .update(playerProfiles)
    .set({
      avatarUrl: imageUrl,
      updatedAt: new Date(),
    })
    .where(eq(playerProfiles.cartridgeUsername, player.displayName))
    .returning();

  if (!profile) {
    return c.json({ error: "Profile not found" }, 404);
  }

  return c.json({
    avatarUrl: profile.avatarUrl,
  });
});

avatarRoutes.get("/history", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const limit = Number(c.req.query("limit")) || 10;

  try {
    const logs = await db
      .select()
      .from(avatarGenerationLogs)
      .where(eq(avatarGenerationLogs.cartridgeUsername, player.displayName))
      .orderBy(desc(avatarGenerationLogs.createdAt))
      .limit(Math.min(limit, 50));

    return c.json({
      logs: logs.map((log) => {
        const imageUrls =
          (log.imageUrls as string[] | null | undefined) ??
          (log.imageUrl ? [log.imageUrl] : []);
        return {
          ...log,
          imageUrls,
        };
      }),
    });
  } catch (error) {
    console.error("Failed to fetch generation history:", error);
    return c.json({ error: "Failed to fetch generation history" }, 500);
  }
});

avatarRoutes.get("/gallery", async (c) => {
  const limit = Number(c.req.query("limit")) || 40;
  const clampedLimit = Math.min(limit, 120);

  try {
    const logs = await db
      .select({
        cartridgeUsername: avatarGenerationLogs.cartridgeUsername,
        prompt: avatarGenerationLogs.prompt,
        imageUrl: avatarGenerationLogs.imageUrl,
        imageUrls: avatarGenerationLogs.imageUrls,
        createdAt: avatarGenerationLogs.createdAt,
      })
      .from(avatarGenerationLogs)
      .orderBy(desc(avatarGenerationLogs.createdAt))
      .limit(Math.min(clampedLimit, 100));

    const images = logs.flatMap((log) => {
      const imageUrls =
        (log.imageUrls as string[] | null | undefined) ??
        (log.imageUrl ? [log.imageUrl] : []);

      return imageUrls.map((url) => ({
        imageUrl: url,
        prompt: log.prompt,
        cartridgeUsername: log.cartridgeUsername,
        createdAt: log.createdAt.toISOString(),
      }));
    });

    return c.json({ images: images.slice(0, clampedLimit) });
  } catch (error) {
    console.error("Failed to fetch avatar gallery:", error);
    return c.json({ error: "Failed to fetch avatar gallery" }, 500);
  }
});

export default avatarRoutes;
