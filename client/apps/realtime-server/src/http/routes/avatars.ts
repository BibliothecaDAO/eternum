import { randomUUID } from "crypto";
import { and, desc, eq, or, sql } from "drizzle-orm";
import { Hono } from "hono";

import { db } from "../../db/client";
import { avatarGenerationLogs, playerProfiles } from "../../db/schema/profiles";
import { generateAvatar, getGenerationStatus } from "../../services/fal-client";
import type { AppEnv } from "../middleware/auth";
import { requirePlayerSession } from "../middleware/auth";
import { avatarRateLimit, incrementRateLimit } from "../middleware/rate-limit";

export const avatarRoutes = new Hono<AppEnv>();

const GENERATION_WINDOW_MS = 24 * 60 * 60 * 1000;
const MAX_GENERATIONS_PER_WEEK =
  Number(process.env.AVATAR_MAX_GENERATIONS_PER_DAY) || Number(process.env.AVATAR_MAX_GENERATIONS_PER_WEEK) || 1;
const MAX_PROFILE_BATCH = 100;

avatarRoutes.post("/generate", requirePlayerSession, avatarRateLimit, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const body = await c.req.json().catch(() => ({}));
  const { prompt, style } = body;

  if (!prompt || typeof prompt !== "string" || prompt.trim().length === 0) {
    return c.json({ error: "Prompt is required" }, 400);
  }

  if (prompt.length > 500) {
    return c.json({ error: "Prompt is too long (max 500 characters)" }, 400);
  }

  const sanitizedPrompt = prompt.trim();
  const now = new Date();
  const generationCutoff = new Date(now.getTime() - GENERATION_WINDOW_MS);

  const [limitProfile] = await db
    .select({
      generationCount: playerProfiles.generationCount,
      lastGenerationAt: playerProfiles.lastGenerationAt,
    })
    .from(playerProfiles)
    .where(eq(playerProfiles.cartridgeUsername, player.displayName))
    .limit(1);

  if (limitProfile?.lastGenerationAt && limitProfile.lastGenerationAt >= generationCutoff) {
    const usedCount = limitProfile.generationCount ?? 0;
    if (usedCount >= MAX_GENERATIONS_PER_WEEK) {
      const resetAtMs = limitProfile.lastGenerationAt.getTime() + GENERATION_WINDOW_MS;
      const resetInHours = Math.max(1, Math.ceil((resetAtMs - now.getTime()) / (60 * 60 * 1000)));
      return c.json(
        {
          error: "Rate limit exceeded",
          message: `You have reached the maximum of ${MAX_GENERATIONS_PER_WEEK} avatar generations per 24 hours`,
          resetInHours,
          resetAt: new Date(resetAtMs).toISOString(),
        },
        429,
      );
    }
  }

  const logId = randomUUID();

  try {
    await db.insert(avatarGenerationLogs).values({
      id: logId,
      cartridgeUsername: player.displayName,
      prompt: sanitizedPrompt,
      status: "pending",
      falJobId: null,
      errorMessage: null,
      imageUrl: null,
      imageUrls: [],
    });

    const result = await generateAvatar({
      prompt: sanitizedPrompt,
      style: style || undefined,
    });

    const primaryImageUrl = result.imageUrls[0];
    if (!primaryImageUrl) {
      throw new Error("No images generated by Fal AI");
    }

    await db
      .update(avatarGenerationLogs)
      .set({
        status: "completed",
        falJobId: result.jobId,
        imageUrl: primaryImageUrl,
        imageUrls: result.imageUrls,
      })
      .where(eq(avatarGenerationLogs.id, logId));

    const [profile] = await db
      .insert(playerProfiles)
      .values({
        cartridgeUsername: player.displayName,
        playerAddress: player.playerId,
        avatarUrl: primaryImageUrl,
        avatarGenerationPrompt: sanitizedPrompt,
        falImageId: result.jobId,
        generationCount: 1,
        lastGenerationAt: now,
        createdAt: now,
        updatedAt: now,
      })
      .onConflictDoUpdate({
        target: playerProfiles.cartridgeUsername,
        set: {
          avatarUrl: primaryImageUrl,
          avatarGenerationPrompt: sanitizedPrompt,
          falImageId: result.jobId,
          generationCount: sql`CASE WHEN ${playerProfiles.lastGenerationAt} IS NULL OR ${playerProfiles.lastGenerationAt} < ${generationCutoff} THEN 1 ELSE ${playerProfiles.generationCount} + 1 END`,
          lastGenerationAt: now,
          updatedAt: now,
        },
      })
      .returning();

    incrementRateLimit(player.displayName);

    return c.json(
      {
        success: true,
        jobId: result.jobId,
        imageUrls: result.imageUrls,
        profile,
      },
      201,
    );
  } catch (error) {
    console.error("Failed to generate avatar:", error);

    await db
      .update(avatarGenerationLogs)
      .set({
        status: "failed",
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      })
      .where(eq(avatarGenerationLogs.id, logId));

    return c.json({ error: "Failed to generate avatar. Please try again later." }, 500);
  }
});

avatarRoutes.get("/status/:jobId", requirePlayerSession, async (c) => {
  const jobId = c.req.param("jobId");

  if (!jobId) {
    return c.json({ error: "Job ID is required" }, 400);
  }

  try {
    const status = await getGenerationStatus(jobId);
    return c.json(status);
  } catch (error) {
    console.error("Failed to check generation status:", error);
    return c.json({ error: "Failed to check generation status" }, 500);
  }
});

avatarRoutes.get("/profile/:username", async (c) => {
  const username = c.req.param("username");

  if (!username) {
    return c.json({ error: "Username is required" }, 400);
  }
  const normalizedUsername = username.trim().toLowerCase();
  if (!normalizedUsername) {
    return c.json({ error: "Username is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(sql`lower(${playerProfiles.cartridgeUsername}) = ${normalizedUsername}`)
      .limit(1);

    if (!profile) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.post("/profiles-by-username", async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { usernames } = body;

  if (!Array.isArray(usernames)) {
    return c.json({ error: "usernames must be an array" }, 400);
  }

  const normalizedUsernames = Array.from(
    new Set(
      usernames
        .filter((username: unknown): username is string => typeof username === "string")
        .map((username) => username.trim().toLowerCase())
        .filter((username) => username.length > 0),
    ),
  ).slice(0, MAX_PROFILE_BATCH);

  if (normalizedUsernames.length === 0) {
    return c.json({ profiles: [] });
  }

  try {
    const rows = await db
      .select({
        cartridgeUsername: playerProfiles.cartridgeUsername,
        playerAddress: playerProfiles.playerAddress,
        avatarUrl: playerProfiles.avatarUrl,
      })
      .from(playerProfiles)
      .where(
        sql`lower(${playerProfiles.cartridgeUsername}) in (${sql.join(
          normalizedUsernames.map((username) => sql`${username}`),
          sql`, `,
        )})`,
      );

    return c.json({ profiles: rows });
  } catch (error) {
    console.error("Failed to fetch avatar profiles by username:", error);
    return c.json({ error: "Failed to fetch avatar profiles" }, 500);
  }
});

avatarRoutes.get("/profile-by-address/:address", async (c) => {
  const address = c.req.param("address");

  if (!address) {
    return c.json({ error: "Address is required" }, 400);
  }
  const normalizedAddress = address.trim().toLowerCase();
  if (!normalizedAddress) {
    return c.json({ error: "Address is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(sql`lower(${playerProfiles.playerAddress}) = ${normalizedAddress}`)
      .limit(1);

    if (!profile) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.post("/profiles", async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { addresses } = body;

  if (!Array.isArray(addresses)) {
    return c.json({ error: "addresses must be an array" }, 400);
  }

  const normalizedAddresses = Array.from(
    new Set(
      addresses
        .filter((address: unknown): address is string => typeof address === "string")
        .map((address) => address.trim().toLowerCase())
        .filter((address) => address.length > 0),
    ),
  ).slice(0, MAX_PROFILE_BATCH);

  if (normalizedAddresses.length === 0) {
    return c.json({ profiles: [] });
  }

  try {
    const rows = await db
      .select({
        cartridgeUsername: playerProfiles.cartridgeUsername,
        playerAddress: playerProfiles.playerAddress,
        avatarUrl: playerProfiles.avatarUrl,
      })
      .from(playerProfiles)
      .where(
        sql`lower(${playerProfiles.playerAddress}) in (${sql.join(
          normalizedAddresses.map((address) => sql`${address}`),
          sql`, `,
        )})`,
      );

    return c.json({ profiles: rows });
  } catch (error) {
    console.error("Failed to fetch avatar profiles:", error);
    return c.json({ error: "Failed to fetch avatar profiles" }, 500);
  }
});

avatarRoutes.get("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  try {
    const [profile] = await db
      .select()
      .from(playerProfiles)
      .where(eq(playerProfiles.cartridgeUsername, player.displayName))
      .limit(1);

    if (!profile) {
      return c.json(
        {
          cartridgeUsername: player.displayName,
          playerAddress: player.playerId,
          avatarUrl: null,
          createdAt: null,
        },
        200,
      );
    }

    const now = Date.now();
    const lastGenerationAt = profile.lastGenerationAt;
    const isWithinWindow = lastGenerationAt && now - lastGenerationAt.getTime() < GENERATION_WINDOW_MS;
    const generationCount = isWithinWindow ? profile.generationCount : 0;
    const nextResetAt = isWithinWindow
      ? new Date(lastGenerationAt.getTime() + GENERATION_WINDOW_MS).toISOString()
      : null;

    return c.json({
      cartridgeUsername: profile.cartridgeUsername,
      playerAddress: profile.playerAddress,
      avatarUrl: profile.avatarUrl,
      createdAt: profile.createdAt.toISOString(),
      generationCount,
      nextResetAt,
    });
  } catch (error) {
    console.error("Failed to fetch profile:", error);
    return c.json({ error: "Failed to fetch profile" }, 500);
  }
});

avatarRoutes.delete("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  try {
    const { rowCount } = await db
      .update(playerProfiles)
      .set({
        avatarUrl: null,
        updatedAt: new Date(),
      })
      .where(eq(playerProfiles.cartridgeUsername, player.displayName));

    if (rowCount === 0) {
      return c.json({ error: "Profile not found" }, 404);
    }

    return c.body(null, 204);
  } catch (error) {
    console.error("Failed to delete avatar:", error);
    return c.json({ error: "Failed to delete avatar" }, 500);
  }
});

avatarRoutes.patch("/me", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const body = await c.req.json().catch(() => ({}));
  const { imageUrl } = body;

  if (!imageUrl || typeof imageUrl !== "string") {
    return c.json({ error: "imageUrl is required" }, 400);
  }

  const [matchingLog] = await db
    .select({ id: avatarGenerationLogs.id })
    .from(avatarGenerationLogs)
    .where(
      and(
        eq(avatarGenerationLogs.cartridgeUsername, player.displayName),
        or(
          eq(avatarGenerationLogs.imageUrl, imageUrl),
          sql`${avatarGenerationLogs.imageUrls} @> ${JSON.stringify([imageUrl])}::jsonb`,
        ),
      ),
    )
    .limit(1);

  if (!matchingLog) {
    return c.json({ error: "Avatar image not found for this user" }, 404);
  }

  const [profile] = await db
    .update(playerProfiles)
    .set({
      avatarUrl: imageUrl,
      updatedAt: new Date(),
    })
    .where(eq(playerProfiles.cartridgeUsername, player.displayName))
    .returning();

  if (!profile) {
    return c.json({ error: "Profile not found" }, 404);
  }

  return c.json({
    avatarUrl: profile.avatarUrl,
  });
});

avatarRoutes.get("/history", requirePlayerSession, async (c) => {
  const player = c.get("playerSession")!;

  if (!player.displayName) {
    return c.json({ error: "Cartridge username is required" }, 400);
  }

  const limit = Number(c.req.query("limit")) || 10;

  try {
    const logs = await db
      .select()
      .from(avatarGenerationLogs)
      .where(eq(avatarGenerationLogs.cartridgeUsername, player.displayName))
      .orderBy(desc(avatarGenerationLogs.createdAt))
      .limit(Math.min(limit, 50));

    return c.json({
      logs: logs.map((log) => {
        const imageUrls = (log.imageUrls as string[] | null | undefined) ?? (log.imageUrl ? [log.imageUrl] : []);
        return {
          ...log,
          imageUrls,
        };
      }),
    });
  } catch (error) {
    console.error("Failed to fetch generation history:", error);
    return c.json({ error: "Failed to fetch generation history" }, 500);
  }
});

avatarRoutes.get("/gallery", async (c) => {
  const limit = Number(c.req.query("limit")) || 40;
  const clampedLimit = Math.min(limit, 120);

  try {
    const logs = await db
      .select({
        cartridgeUsername: avatarGenerationLogs.cartridgeUsername,
        prompt: avatarGenerationLogs.prompt,
        imageUrl: avatarGenerationLogs.imageUrl,
        imageUrls: avatarGenerationLogs.imageUrls,
        createdAt: avatarGenerationLogs.createdAt,
      })
      .from(avatarGenerationLogs)
      .orderBy(desc(avatarGenerationLogs.createdAt))
      .limit(Math.min(clampedLimit, 100));

    const images = logs.flatMap((log) => {
      const imageUrls = (log.imageUrls as string[] | null | undefined) ?? (log.imageUrl ? [log.imageUrl] : []);

      return imageUrls.map((url) => ({
        imageUrl: url,
        prompt: log.prompt,
        cartridgeUsername: log.cartridgeUsername,
        createdAt: log.createdAt.toISOString(),
      }));
    });

    return c.json({ images: images.slice(0, clampedLimit) });
  } catch (error) {
    console.error("Failed to fetch avatar gallery:", error);
    return c.json({ error: "Failed to fetch avatar gallery" }, 500);
  }
});

export default avatarRoutes;
