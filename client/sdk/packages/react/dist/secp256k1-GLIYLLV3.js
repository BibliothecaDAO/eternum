import{c as sn}from"./chunk-LURIOADG.js";function Se(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function cn(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function vt(t,...n){if(!cn(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function Ie(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Se(t.outputLen),Se(t.blockLen)}function At(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Oe(t,n){vt(t);let e=n.outputLen;if(t.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}import*as et from"node:crypto";var gt=et&&typeof et=="object"&&"webcrypto"in et?et.webcrypto:et&&typeof et=="object"&&"randomBytes"in et?et:void 0;var Ct=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),X=(t,n)=>t<<32-n|t>>>n;function fn(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function Tt(t){return typeof t=="string"&&(t=fn(t)),vt(t),t}function _e(...t){let n=0;for(let r=0;r<t.length;r++){let o=t[r];vt(o),n+=o.length}let e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){let i=t[r];e.set(i,o),o+=i.length}return e}var St=class{clone(){return this._cloneInto()}};function Te(t){let n=r=>t().update(Tt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Vt(t=32){if(gt&&typeof gt.getRandomValues=="function")return gt.getRandomValues(new Uint8Array(t));if(gt&&typeof gt.randomBytes=="function")return gt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function an(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);let o=BigInt(32),i=BigInt(4294967295),c=Number(e>>o&i),f=Number(e&i),s=r?4:0,u=r?0:4;t.setUint32(n+s,c,r),t.setUint32(n+u,f,r)}var Le=(t,n,e)=>t&n^~t&e,qe=(t,n,e)=>t&n^t&e^n&e,Zt=class extends St{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ct(this.buffer)}update(n){At(this);let{view:e,buffer:r,blockLen:o}=this;n=Tt(n);let i=n.length;for(let c=0;c<i;){let f=Math.min(o-this.pos,i-c);if(f===o){let s=Ct(n);for(;o<=i-c;c+=o)this.process(s,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){At(this),Oe(n,this),this.finished=!0;let{buffer:e,view:r,blockLen:o,isLE:i}=this,{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let d=c;d<o;d++)e[d]=0;an(r,o-8,BigInt(this.length*8),i),this.process(r,0);let f=Ct(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=s/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)f.setUint32(4*d,h[d],i)}digest(){let{buffer:n,outputLen:e}=this;this.digestInto(n);let r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());let{blockLen:e,buffer:r,length:o,finished:i,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=i,n.destroyed=c,o%e&&n.buffer.set(r),n}};var un=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),st=new Uint32Array(64),re=class extends Zt{constructor(){super(64,32,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){let{A:n,B:e,C:r,D:o,E:i,F:c,G:f,H:s}=this;return[n,e,r,o,i,c,f,s]}set(n,e,r,o,i,c,f,s){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=c|0,this.G=f|0,this.H=s|0}process(n,e){for(let d=0;d<16;d++,e+=4)st[d]=n.getUint32(e,!1);for(let d=16;d<64;d++){let l=st[d-15],p=st[d-2],B=X(l,7)^X(l,18)^l>>>3,b=X(p,17)^X(p,19)^p>>>10;st[d]=b+st[d-7]+B+st[d-16]|0}let{A:r,B:o,C:i,D:c,E:f,F:s,G:u,H:h}=this;for(let d=0;d<64;d++){let l=X(f,6)^X(f,11)^X(f,25),p=h+l+Le(f,s,u)+un[d]+st[d]|0,b=(X(r,2)^X(r,13)^X(r,22))+qe(r,o,i)|0;h=u,u=s,s=f,f=c+p|0,c=i,i=o,o=r,r=p+b|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,c=c+this.D|0,f=f+this.E|0,s=s+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(r,o,i,c,f,s,u,h)}roundClean(){st.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Lt=Te(()=>new re);var Mt=class extends St{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ie(n);let r=Tt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return At(this),this.iHash.update(n),this}digestInto(n){At(this),vt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:c,outputLen:f}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},oe=(t,n,e)=>new Mt(t,n).update(e).digest();oe.create=(t,n)=>new Mt(t,n);var ue={};sn(ue,{aInRange:()=>$,abool:()=>pt,abytes:()=>G,bitGet:()=>pn,bitLen:()=>fe,bitMask:()=>Nt,bitSet:()=>mn,bytesToHex:()=>mt,bytesToNumberBE:()=>D,bytesToNumberLE:()=>Pt,concatBytes:()=>M,createHmacDrbg:()=>ae,ensureBytes:()=>C,equalBytes:()=>gn,hexToBytes:()=>bt,hexToNumber:()=>ce,inRange:()=>ft,isBytes:()=>ct,memoized:()=>Kt,notImplemented:()=>bn,numberToBytesBE:()=>Q,numberToBytesLE:()=>Dt,numberToHexUnpadded:()=>wt,numberToVarBytesBE:()=>hn,utf8ToBytes:()=>qt,validateObject:()=>F});var jt=BigInt(0),zt=BigInt(1),dn=BigInt(2);function ct(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function G(t){if(!ct(t))throw new Error("Uint8Array expected")}function pt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}var ln=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function mt(t){G(t);let n="";for(let e=0;e<t.length;e++)n+=ln[t[e]];return n}function wt(t){let n=t.toString(16);return n.length&1?"0"+n:n}function ce(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?jt:BigInt("0x"+t)}var nt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ne(t){if(t>=nt._0&&t<=nt._9)return t-nt._0;if(t>=nt.A&&t<=nt.F)return t-(nt.A-10);if(t>=nt.a&&t<=nt.f)return t-(nt.a-10)}function bt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);let r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){let c=Ne(t.charCodeAt(i)),f=Ne(t.charCodeAt(i+1));if(c===void 0||f===void 0){let s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=c*16+f}return r}function D(t){return ce(mt(t))}function Pt(t){return G(t),ce(mt(Uint8Array.from(t).reverse()))}function Q(t,n){return bt(t.toString(16).padStart(n*2,"0"))}function Dt(t,n){return Q(t,n).reverse()}function hn(t){return bt(wt(t))}function C(t,n,e){let r;if(typeof n=="string")try{r=bt(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(ct(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");let o=r.length;if(typeof e=="number"&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function M(...t){let n=0;for(let r=0;r<t.length;r++){let o=t[r];G(o),n+=o.length}let e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){let i=t[r];e.set(i,o),o+=i.length}return e}function gn(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function qt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}var ie=t=>typeof t=="bigint"&&jt<=t;function ft(t,n,e){return ie(t)&&ie(n)&&ie(e)&&n<=t&&t<e}function $(t,n,e,r){if(!ft(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function fe(t){let n;for(n=0;t>jt;t>>=zt,n+=1);return n}function pn(t,n){return t>>BigInt(n)&zt}function mn(t,n,e){return t|(e?zt:jt)<<BigInt(n)}var Nt=t=>(dn<<BigInt(t-1))-zt,se=t=>new Uint8Array(t),Ue=t=>Uint8Array.from(t);function ae(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=se(t),o=se(t),i=0,c=()=>{r.fill(1),o.fill(0),i=0},f=(...d)=>e(o,r,...d),s=(d=se())=>{o=f(Ue([0]),d),r=f(),d.length!==0&&(o=f(Ue([1]),d),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0,l=[];for(;d<n;){r=f();let p=r.slice();l.push(p),d+=r.length}return M(...l)};return(d,l)=>{c(),s(d);let p;for(;!(p=l(u()));)s();return c(),p}}var wn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||ct(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function F(t,n,e={}){let r=(o,i,c)=>{let f=wn[i];if(typeof f!="function")throw new Error("invalid validator function");let s=t[o];if(!(c&&s===void 0)&&!f(s,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+s)};for(let[o,i]of Object.entries(n))r(o,i,!1);for(let[o,i]of Object.entries(e))r(o,i,!0);return t}var bn=()=>{throw new Error("not implemented")};function Kt(t){let n=new WeakMap;return(e,...r)=>{let o=n.get(e);if(o!==void 0)return o;let i=t(e,...r);return n.set(e,i),i}}var V=BigInt(0),R=BigInt(1),yt=BigInt(2),yn=BigInt(3),de=BigInt(4),Re=BigInt(5),He=BigInt(8),xn=BigInt(9),En=BigInt(16);function H(t,n){let e=t%n;return e>=V?e:n+e}function Bn(t,n,e){if(n<V)throw new Error("invalid exponent, negatives unsupported");if(e<=V)throw new Error("invalid modulus");if(e===R)return V;let r=R;for(;n>V;)n&R&&(r=r*t%e),t=t*t%e,n>>=R;return r}function Y(t,n,e){let r=t;for(;n-- >V;)r*=r,r%=e;return r}function Yt(t,n){if(t===V)throw new Error("invert: expected non-zero number");if(n<=V)throw new Error("invert: expected positive modulus, got "+n);let e=H(t,n),r=n,o=V,i=R,c=R,f=V;for(;e!==V;){let u=r/e,h=r%e,d=o-c*u,l=i-f*u;r=e,e=h,o=c,i=f,c=d,f=l}if(r!==R)throw new Error("invert: does not exist");return H(o,n)}function vn(t){let n=(t-R)/yt,e,r,o;for(e=t-R,r=0;e%yt===V;e/=yt,r++);for(o=yt;o<t&&Bn(o,n,t)!==t-R;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){let c=(t+R)/de;return function(s,u){let h=s.pow(u,c);if(!s.eql(s.sqr(h),u))throw new Error("Cannot find square root");return h}}let i=(e+R)/yt;return function(f,s){if(f.pow(s,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let u=r,h=f.pow(f.mul(f.ONE,o),e),d=f.pow(s,i),l=f.pow(s,e);for(;!f.eql(l,f.ONE);){if(f.eql(l,f.ZERO))return f.ZERO;let p=1;for(let b=f.sqr(l);p<u&&!f.eql(b,f.ONE);p++)b=f.sqr(b);let B=f.pow(h,R<<BigInt(u-p-1));h=f.sqr(B),d=f.mul(d,B),l=f.mul(l,h),u=p}return d}}function An(t){if(t%de===yn){let n=(t+R)/de;return function(r,o){let i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%He===Re){let n=(t-Re)/He;return function(r,o){let i=r.mul(o,yt),c=r.pow(i,n),f=r.mul(o,c),s=r.mul(r.mul(f,yt),c),u=r.mul(f,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return t%En,vn(t)}var Sn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Gt(t){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Sn.reduce((r,o)=>(r[o]="function",r),n);return F(t,e)}function In(t,n,e){if(e<V)throw new Error("invalid exponent, negatives unsupported");if(e===V)return t.ONE;if(e===R)return n;let r=t.ONE,o=n;for(;e>V;)e&R&&(r=t.mul(r,o)),o=t.sqr(o),e>>=R;return r}function On(t,n){let e=new Array(n.length),r=n.reduce((i,c,f)=>t.is0(c)?i:(e[f]=i,t.mul(i,c)),t.ONE),o=t.inv(r);return n.reduceRight((i,c,f)=>t.is0(c)?i:(e[f]=t.mul(i,e[f]),t.mul(i,c)),o),e}function le(t,n){let e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Wt(t,n,e=!1,r={}){if(t<=V)throw new Error("invalid field: expected ORDER > 0, got "+t);let{nBitLength:o,nByteLength:i}=le(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,f=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:Nt(o),ZERO:V,ONE:R,create:s=>H(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return V<=s&&s<t},is0:s=>s===V,isOdd:s=>(s&R)===R,neg:s=>H(-s,t),eql:(s,u)=>s===u,sqr:s=>H(s*s,t),add:(s,u)=>H(s+u,t),sub:(s,u)=>H(s-u,t),mul:(s,u)=>H(s*u,t),pow:(s,u)=>In(f,s,u),div:(s,u)=>H(s*Yt(u,t),t),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>Yt(s,t),sqrt:r.sqrt||(s=>(c||(c=An(t)),c(f,s))),invertBatch:s=>On(f,s),cmov:(s,u,h)=>h?u:s,toBytes:s=>e?Dt(s,i):Q(s,i),fromBytes:s=>{if(s.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+s.length);return e?Pt(s):D(s)}});return Object.freeze(f)}function ke(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let n=t.toString(2).length;return Math.ceil(n/8)}function he(t){let n=ke(t);return n+Math.ceil(n/2)}function Ce(t,n,e=!1){let r=t.length,o=ke(n),i=he(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);let c=e?D(t):Pt(t),f=H(c,n-R)+R;return e?Dt(f,o):Q(f,o)}var Ve=BigInt(0),Xt=BigInt(1);function ge(t,n){let e=n.negate();return t?e:n}function Ze(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function pe(t,n){Ze(t,n);let e=Math.ceil(n/t)+1,r=2**(t-1);return{windows:e,windowSize:r}}function Tn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Ln(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}var me=new WeakMap,Me=new WeakMap;function we(t){return Me.get(t)||1}function je(t,n){return{constTimeNegate:ge,hasPrecomputes(e){return we(e)!==1},unsafeLadder(e,r,o=t.ZERO){let i=e;for(;r>Ve;)r&Xt&&(o=o.add(i)),i=i.double(),r>>=Xt;return o},precomputeWindow(e,r){let{windows:o,windowSize:i}=pe(r,n),c=[],f=e,s=f;for(let u=0;u<o;u++){s=f,c.push(s);for(let h=1;h<i;h++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(e,r,o){let{windows:i,windowSize:c}=pe(e,n),f=t.ZERO,s=t.BASE,u=BigInt(2**e-1),h=2**e,d=BigInt(e);for(let l=0;l<i;l++){let p=l*c,B=Number(o&u);o>>=d,B>c&&(B-=h,o+=Xt);let b=p,a=p+Math.abs(B)-1,g=l%2!==0,m=B<0;B===0?s=s.add(ge(g,r[b])):f=f.add(ge(m,r[a]))}return{p:f,f:s}},wNAFUnsafe(e,r,o,i=t.ZERO){let{windows:c,windowSize:f}=pe(e,n),s=BigInt(2**e-1),u=2**e,h=BigInt(e);for(let d=0;d<c;d++){let l=d*f;if(o===Ve)break;let p=Number(o&s);if(o>>=h,p>f&&(p-=u,o+=Xt),p===0)continue;let B=r[l+Math.abs(p)-1];p<0&&(B=B.negate()),i=i.add(B)}return i},getPrecomputes(e,r,o){let i=me.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&me.set(r,o(i))),i},wNAFCached(e,r,o){let i=we(e);return this.wNAF(i,this.getPrecomputes(i,e,o),r)},wNAFCachedUnsafe(e,r,o,i){let c=we(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,i)},setWindowSize(e,r){Ze(r,n),Me.set(e,r),me.delete(e)}}}function ze(t,n,e,r){if(Tn(e,t),Ln(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");let o=t.ZERO,i=fe(BigInt(e.length)),c=i>12?i-3:i>4?i-2:i?2:1,f=(1<<c)-1,s=new Array(f+1).fill(o),u=Math.floor((n.BITS-1)/c)*c,h=o;for(let d=u;d>=0;d-=c){s.fill(o);for(let p=0;p<r.length;p++){let B=r[p],b=Number(B>>BigInt(d)&BigInt(f));s[b]=s[b].add(e[p])}let l=o;for(let p=s.length-1,B=o;p>0;p--)B=B.add(s[p]),l=l.add(B);if(h=h.add(l),d!==0)for(let p=0;p<c;p++)h=h.double()}return h}function be(t){return Gt(t.Fp),F(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...le(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Pe(t){t.lowS!==void 0&&pt("lowS",t.lowS),t.prehash!==void 0&&pt("prehash",t.prehash)}function qn(t){let n=be(t);F(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}var{bytesToNumberBE:Nn,hexToBytes:Un}=ue,rt={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(t,n)=>{let{Err:e}=rt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");let r=n.length/2,o=wt(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");let i=r>127?wt(o.length/2|128):"";return wt(t)+i+o+n},decode(t,n){let{Err:e}=rt,r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");let o=n[r++],i=!!(o&128),c=0;if(!i)c=o;else{let s=o&127;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");let u=n.subarray(r,r+s);if(u.length!==s)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let h of u)c=c<<8|h;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}let f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){let{Err:n}=rt;if(t<J)throw new n("integer: negative integers are not allowed");let e=wt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){let{Err:n}=rt;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return Nn(t)}},toSig(t){let{Err:n,_int:e,_tlv:r}=rt,o=typeof t=="string"?Un(t):t;G(o);let{v:i,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:f,l:s}=r.decode(2,i),{v:u,l:h}=r.decode(2,s);if(h.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){let{_tlv:n,_int:e}=rt,r=n.encode(2,e.encode(t.r)),o=n.encode(2,e.encode(t.s)),i=r+o;return n.encode(48,i)}},J=BigInt(0),N=BigInt(1),at=BigInt(2),Qt=BigInt(3),De=BigInt(4);function Rn(t){let n=qn(t),{Fp:e}=n,r=Wt(n.n,n.nBitLength),o=n.toBytes||((b,a,g)=>{let m=a.toAffine();return M(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),i=n.fromBytes||(b=>{let a=b.subarray(1),g=e.fromBytes(a.subarray(0,e.BYTES)),m=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:g,y:m}});function c(b){let{a,b:g}=n,m=e.sqr(b),y=e.mul(m,b);return e.add(e.add(y,e.mul(b,a)),g)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(b){return ft(b,N,n.n)}function s(b){let{allowedPrivateKeyLengths:a,nByteLength:g,wrapPrivateKey:m,n:y}=n;if(a&&typeof b!="bigint"){if(ct(b)&&(b=mt(b)),typeof b!="string"||!a.includes(b.length))throw new Error("invalid private key");b=b.padStart(g*2,"0")}let v;try{v=typeof b=="bigint"?b:D(C("private key",b,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof b)}return m&&(v=H(v,y)),$("private key",v,N,y),v}function u(b){if(!(b instanceof l))throw new Error("ProjectivePoint expected")}let h=Kt((b,a)=>{let{px:g,py:m,pz:y}=b;if(e.eql(y,e.ONE))return{x:g,y:m};let v=b.is0();a==null&&(a=v?e.ONE:e.inv(y));let T=e.mul(g,a),O=e.mul(m,a),A=e.mul(y,a);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(A,e.ONE))throw new Error("invZ was invalid");return{x:T,y:O}}),d=Kt(b=>{if(b.is0()){if(n.allowInfinityPoint&&!e.is0(b.py))return;throw new Error("bad point: ZERO")}let{x:a,y:g}=b.toAffine();if(!e.isValid(a)||!e.isValid(g))throw new Error("bad point: x or y not FE");let m=e.sqr(g),y=c(a);if(!e.eql(m,y))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(a,g,m){if(this.px=a,this.py=g,this.pz=m,a==null||!e.isValid(a))throw new Error("x required");if(g==null||!e.isValid(g))throw new Error("y required");if(m==null||!e.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(a){let{x:g,y:m}=a||{};if(!a||!e.isValid(g)||!e.isValid(m))throw new Error("invalid affine point");if(a instanceof l)throw new Error("projective point not allowed");let y=v=>e.eql(v,e.ZERO);return y(g)&&y(m)?l.ZERO:new l(g,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){let g=e.invertBatch(a.map(m=>m.pz));return a.map((m,y)=>m.toAffine(g[y])).map(l.fromAffine)}static fromHex(a){let g=l.fromAffine(i(C("pointHex",a)));return g.assertValidity(),g}static fromPrivateKey(a){return l.BASE.multiply(s(a))}static msm(a,g){return ze(l,r,a,g)}_setWindowSize(a){B.setWindowSize(this,a)}assertValidity(){d(this)}hasEvenY(){let{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);let{px:g,py:m,pz:y}=this,{px:v,py:T,pz:O}=a,A=e.eql(e.mul(g,O),e.mul(v,y)),I=e.eql(e.mul(m,O),e.mul(T,y));return A&&I}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){let{a,b:g}=n,m=e.mul(g,Qt),{px:y,py:v,pz:T}=this,O=e.ZERO,A=e.ZERO,I=e.ZERO,S=e.mul(y,y),Z=e.mul(v,v),U=e.mul(T,T),q=e.mul(y,v);return q=e.add(q,q),I=e.mul(y,T),I=e.add(I,I),O=e.mul(a,I),A=e.mul(m,U),A=e.add(O,A),O=e.sub(Z,A),A=e.add(Z,A),A=e.mul(O,A),O=e.mul(q,O),I=e.mul(m,I),U=e.mul(a,U),q=e.sub(S,U),q=e.mul(a,q),q=e.add(q,I),I=e.add(S,S),S=e.add(I,S),S=e.add(S,U),S=e.mul(S,q),A=e.add(A,S),U=e.mul(v,T),U=e.add(U,U),S=e.mul(U,q),O=e.sub(O,S),I=e.mul(U,Z),I=e.add(I,I),I=e.add(I,I),new l(O,A,I)}add(a){u(a);let{px:g,py:m,pz:y}=this,{px:v,py:T,pz:O}=a,A=e.ZERO,I=e.ZERO,S=e.ZERO,Z=n.a,U=e.mul(n.b,Qt),q=e.mul(g,v),K=e.mul(m,T),w=e.mul(y,O),x=e.add(g,m),E=e.add(v,T);x=e.mul(x,E),E=e.add(q,K),x=e.sub(x,E),E=e.add(g,y);let _=e.add(v,O);return E=e.mul(E,_),_=e.add(q,w),E=e.sub(E,_),_=e.add(m,y),A=e.add(T,O),_=e.mul(_,A),A=e.add(K,w),_=e.sub(_,A),S=e.mul(Z,E),A=e.mul(U,w),S=e.add(A,S),A=e.sub(K,S),S=e.add(K,S),I=e.mul(A,S),K=e.add(q,q),K=e.add(K,q),w=e.mul(Z,w),E=e.mul(U,E),K=e.add(K,w),w=e.sub(q,w),w=e.mul(Z,w),E=e.add(E,w),q=e.mul(K,E),I=e.add(I,q),q=e.mul(_,E),A=e.mul(x,A),A=e.sub(A,q),q=e.mul(x,K),S=e.mul(_,S),S=e.add(S,q),new l(A,I,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(l.ZERO)}wNAF(a){return B.wNAFCached(this,a,l.normalizeZ)}multiplyUnsafe(a){let{endo:g,n:m}=n;$("scalar",a,J,m);let y=l.ZERO;if(a===J)return y;if(this.is0()||a===N)return this;if(!g||B.hasPrecomputes(this))return B.wNAFCachedUnsafe(this,a,l.normalizeZ);let{k1neg:v,k1:T,k2neg:O,k2:A}=g.splitScalar(a),I=y,S=y,Z=this;for(;T>J||A>J;)T&N&&(I=I.add(Z)),A&N&&(S=S.add(Z)),Z=Z.double(),T>>=N,A>>=N;return v&&(I=I.negate()),O&&(S=S.negate()),S=new l(e.mul(S.px,g.beta),S.py,S.pz),I.add(S)}multiply(a){let{endo:g,n:m}=n;$("scalar",a,N,m);let y,v;if(g){let{k1neg:T,k1:O,k2neg:A,k2:I}=g.splitScalar(a),{p:S,f:Z}=this.wNAF(O),{p:U,f:q}=this.wNAF(I);S=B.constTimeNegate(T,S),U=B.constTimeNegate(A,U),U=new l(e.mul(U.px,g.beta),U.py,U.pz),y=S.add(U),v=Z.add(q)}else{let{p:T,f:O}=this.wNAF(a);y=T,v=O}return l.normalizeZ([y,v])[0]}multiplyAndAddUnsafe(a,g,m){let y=l.BASE,v=(O,A)=>A===J||A===N||!O.equals(y)?O.multiplyUnsafe(A):O.multiply(A),T=v(this,g).add(v(a,m));return T.is0()?void 0:T}toAffine(a){return h(this,a)}isTorsionFree(){let{h:a,isTorsionFree:g}=n;if(a===N)return!0;if(g)return g(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:a,clearCofactor:g}=n;return a===N?this:g?g(l,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return pt("isCompressed",a),this.assertValidity(),o(l,this,a)}toHex(a=!0){return pt("isCompressed",a),mt(this.toRawBytes(a))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);let p=n.nBitLength,B=je(l,n.endo?Math.ceil(p/2):p);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:f}}function Hn(t){let n=be(t);return F(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ke(t){let n=Hn(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function c(w){return H(w,r)}function f(w){return Yt(w,r)}let{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:d}=Rn({...n,toBytes(w,x,E){let _=x.toAffine(),L=e.toBytes(_.x),k=M;return pt("isCompressed",E),E?k(Uint8Array.from([x.hasEvenY()?2:3]),L):k(Uint8Array.from([4]),L,e.toBytes(_.y))},fromBytes(w){let x=w.length,E=w[0],_=w.subarray(1);if(x===o&&(E===2||E===3)){let L=D(_);if(!ft(L,N,e.ORDER))throw new Error("Point is not on curve");let k=h(L),z;try{z=e.sqrt(k)}catch(W){let P=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+P)}let j=(z&N)===N;return(E&1)===1!==j&&(z=e.neg(z)),{x:L,y:z}}else if(x===i&&E===4){let L=e.fromBytes(_.subarray(0,e.BYTES)),k=e.fromBytes(_.subarray(e.BYTES,2*e.BYTES));return{x:L,y:k}}else{let L=o,k=i;throw new Error("invalid Point, expected length of "+L+", or uncompressed "+k+", got "+x)}}}),l=w=>mt(Q(w,n.nByteLength));function p(w){let x=r>>N;return w>x}function B(w){return p(w)?c(-w):w}let b=(w,x,E)=>D(w.slice(x,E));class a{constructor(x,E,_){this.r=x,this.s=E,this.recovery=_,this.assertValidity()}static fromCompact(x){let E=n.nByteLength;return x=C("compactSignature",x,E*2),new a(b(x,0,E),b(x,E,2*E))}static fromDER(x){let{r:E,s:_}=rt.toSig(C("DER",x));return new a(E,_)}assertValidity(){$("r",this.r,N,r),$("s",this.s,N,r)}addRecoveryBit(x){return new a(this.r,this.s,x)}recoverPublicKey(x){let{r:E,s:_,recovery:L}=this,k=O(C("msgHash",x));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");let z=L===2||L===3?E+n.n:E;if(z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=L&1?"03":"02",tt=s.fromHex(j+l(z)),W=f(z),P=c(-k*W),xt=c(_*W),ot=s.BASE.multiplyAndAddUnsafe(tt,P,xt);if(!ot)throw new Error("point at infinify");return ot.assertValidity(),ot}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return bt(this.toDERHex())}toDERHex(){return rt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return bt(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}let g={isValidPrivateKey(w){try{return u(w),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{let w=he(n.n);return Ce(n.randomBytes(w),n.n)},precompute(w=8,x=s.BASE){return x._setWindowSize(w),x.multiply(BigInt(3)),x}};function m(w,x=!0){return s.fromPrivateKey(w).toRawBytes(x)}function y(w){let x=ct(w),E=typeof w=="string",_=(x||E)&&w.length;return x?_===o||_===i:E?_===2*o||_===2*i:w instanceof s}function v(w,x,E=!0){if(y(w))throw new Error("first arg must be private key");if(!y(x))throw new Error("second arg must be public key");return s.fromHex(x).multiply(u(w)).toRawBytes(E)}let T=n.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");let x=D(w),E=w.length*8-n.nBitLength;return E>0?x>>BigInt(E):x},O=n.bits2int_modN||function(w){return c(T(w))},A=Nt(n.nBitLength);function I(w){return $("num < 2^"+n.nBitLength,w,J,A),Q(w,n.nByteLength)}function S(w,x,E=Z){if(["recovered","canonical"].some(lt=>lt in E))throw new Error("sign() legacy options not supported");let{hash:_,randomBytes:L}=n,{lowS:k,prehash:z,extraEntropy:j}=E;k==null&&(k=!0),w=C("msgHash",w),Pe(E),z&&(w=C("prehashed msgHash",_(w)));let tt=O(w),W=u(x),P=[I(W),I(tt)];if(j!=null&&j!==!1){let lt=j===!0?L(e.BYTES):j;P.push(C("extraEntropy",lt))}let xt=M(...P),ot=tt;function ee(lt){let Et=T(lt);if(!d(Et))return;let ne=f(Et),Ot=s.BASE.multiply(Et).toAffine(),ht=c(Ot.x);if(ht===J)return;let _t=c(ne*c(ot+ht*W));if(_t===J)return;let Bt=(Ot.x===ht?0:2)|Number(Ot.y&N),Ae=_t;return k&&p(_t)&&(Ae=B(_t),Bt^=1),new a(ht,Ae,Bt)}return{seed:xt,k2sig:ee}}let Z={lowS:n.lowS,prehash:!1},U={lowS:n.lowS,prehash:!1};function q(w,x,E=Z){let{seed:_,k2sig:L}=S(w,x,E),k=n;return ae(k.hash.outputLen,k.nByteLength,k.hmac)(_,L)}s.BASE._setWindowSize(8);function K(w,x,E,_=U){let L=w;x=C("msgHash",x),E=C("publicKey",E);let{lowS:k,prehash:z,format:j}=_;if(Pe(_),"strict"in _)throw new Error("options.strict was renamed to lowS");if(j!==void 0&&j!=="compact"&&j!=="der")throw new Error("format must be compact or der");let tt=typeof L=="string"||ct(L),W=!tt&&!j&&typeof L=="object"&&L!==null&&typeof L.r=="bigint"&&typeof L.s=="bigint";if(!tt&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,xt;try{if(W&&(P=new a(L.r,L.s)),tt){try{j!=="compact"&&(P=a.fromDER(L))}catch(Bt){if(!(Bt instanceof rt.Err))throw Bt}!P&&j!=="der"&&(P=a.fromCompact(L))}xt=s.fromHex(E)}catch{return!1}if(!P||k&&P.hasHighS())return!1;z&&(x=n.hash(x));let{r:ot,s:ee}=P,lt=O(x),Et=f(ee),ne=c(lt*Et),Ot=c(ot*Et),ht=s.BASE.multiplyAndAddUnsafe(xt,ne,Ot)?.toAffine();return ht?c(ht.x)===ot:!1}return{CURVE:n,getPublicKey:m,getSharedSecret:v,sign:q,verify:K,ProjectivePoint:s,Signature:a,utils:g}}function kn(t,n){let e=t.ORDER,r=J;for(let B=e-N;B%at===J;B/=at)r+=N;let o=r,i=at<<o-N-N,c=i*at,f=(e-N)/c,s=(f-N)/at,u=c-N,h=i,d=t.pow(n,f),l=t.pow(n,(f+N)/at),p=(B,b)=>{let a=d,g=t.pow(b,u),m=t.sqr(g);m=t.mul(m,b);let y=t.mul(B,m);y=t.pow(y,s),y=t.mul(y,g),g=t.mul(y,b),m=t.mul(y,B);let v=t.mul(m,g);y=t.pow(v,h);let T=t.eql(y,t.ONE);g=t.mul(m,l),y=t.mul(v,a),m=t.cmov(g,m,T),v=t.cmov(y,v,T);for(let O=o;O>N;O--){let A=O-at;A=at<<A-N;let I=t.pow(v,A),S=t.eql(I,t.ONE);g=t.mul(m,a),a=t.mul(a,a),I=t.mul(v,a),m=t.cmov(g,m,S),v=t.cmov(I,v,S)}return{isValid:T,value:m}};if(t.ORDER%De===Qt){let B=(t.ORDER-Qt)/De,b=t.sqrt(t.neg(n));p=(a,g)=>{let m=t.sqr(g),y=t.mul(a,g);m=t.mul(m,y);let v=t.pow(m,B);v=t.mul(v,y);let T=t.mul(v,b),O=t.mul(t.sqr(v),g),A=t.eql(O,a),I=t.cmov(T,v,A);return{isValid:A,value:I}}}return p}function Ye(t,n){if(Gt(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let e=kn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,c,f,s,u,h,d;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),s=t.mul(u,n.A),i=t.add(i,s),i=t.mul(i,c),u=t.mul(u,f),s=t.mul(u,n.B),i=t.add(i,s),h=t.mul(o,c);let{isValid:l,value:p}=e(i,u);d=t.mul(o,r),d=t.mul(d,p),h=t.cmov(h,c,l),d=t.cmov(d,p,l);let B=t.isOdd(r)===t.isOdd(d);return d=t.cmov(t.neg(d),d,B),h=t.div(h,f),{x:h,y:d}}}function Cn(t){return{hash:t,hmac:(n,...e)=>oe(t,n,_e(...e)),randomBytes:Vt}}function Ge(t,n){let e=r=>Ke({...t,...Cn(r)});return Object.freeze({...e(n),create:e})}var Vn=D;function ut(t,n){if(Ut(t),Ut(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);let e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Zn(t,n){let e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Ut(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Mn(t,n,e,r){G(t),G(n),Ut(e),n.length>255&&(n=r(M(qt("H2C-OVERSIZE-DST-"),n)));let{outputLen:o,blockLen:i}=r,c=Math.ceil(e/o);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");let f=M(n,ut(n.length,1)),s=ut(0,i),u=ut(e,2),h=new Array(c),d=r(M(s,t,u,ut(0,1),f));h[0]=r(M(d,ut(1,1),f));for(let p=1;p<=c;p++){let B=[Zn(d,h[p-1]),ut(p+1,1),f];h[p]=r(M(...B))}return M(...h).slice(0,e)}function jn(t,n,e,r,o){if(G(t),G(n),Ut(e),n.length>255){let i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(qt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(ut(e,2)).update(n).update(ut(n.length,1)).digest()}function We(t,n,e){F(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:o,m:i,hash:c,expand:f,DST:s}=e;G(t),Ut(n);let u=typeof s=="string"?qt(s):s,h=r.toString(2).length,d=Math.ceil((h+o)/8),l=n*i*d,p;if(f==="xmd")p=Mn(t,u,l,c);else if(f==="xof")p=jn(t,u,l,o,c);else if(f==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');let B=new Array(n);for(let b=0;b<n;b++){let a=new Array(i);for(let g=0;g<i;g++){let m=d*(g+b*i),y=p.subarray(m,m+d);a[g]=H(Vn(y),r)}B[b]=a}return B}function Xe(t,n){let e=n.map(r=>Array.from(r).reverse());return(r,o)=>{let[i,c,f,s]=e.map(u=>u.reduce((h,d)=>t.add(t.mul(h,r),d)));return r=t.div(i,c),o=t.mul(o,t.div(f,s)),{x:r,y:o}}}function Qe(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){let i=We(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(i[0])),f=t.fromAffine(n(i[1])),s=c.add(f).clearCofactor();return s.assertValidity(),s},encodeToCurve(r,o){let i=We(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(i[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(let i of r)if(typeof i!="bigint")throw new Error("mapToCurve: expected array of bigints");let o=t.fromAffine(n(r)).clearCofactor();return o.assertValidity(),o}}}var kt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Jt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Rt=BigInt(1),$t=BigInt(2),Je=(t,n)=>(t+n/$t)/n;function Fe(t){let n=kt,e=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),s=BigInt(88),u=t*t*t%n,h=u*u*t%n,d=Y(h,e,n)*h%n,l=Y(d,e,n)*h%n,p=Y(l,$t,n)*u%n,B=Y(p,o,n)*p%n,b=Y(B,i,n)*B%n,a=Y(b,f,n)*b%n,g=Y(a,s,n)*a%n,m=Y(g,f,n)*b%n,y=Y(m,e,n)*h%n,v=Y(y,c,n)*B%n,T=Y(v,r,n)*u%n,O=Y(T,$t,n);if(!dt.eql(dt.sqr(O),t))throw new Error("Cannot find square root");return O}var dt=Wt(kt,void 0,void 0,{sqrt:Fe}),te=Ge({a:BigInt(0),b:BigInt(7),Fp:dt,n:Jt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let n=Jt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Rt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=Je(i*t,n),s=Je(-r*t,n),u=H(t-f*e-s*o,n),h=H(-f*r-s*i,n),d=u>c,l=h>c;if(d&&(u=n-u),l&&(h=n-h),u>c||h>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:d,k1:u,k2neg:l,k2:h}}}},Lt),tn=BigInt(0),$e={};function Ft(t,...n){let e=$e[t];if(e===void 0){let r=Lt(Uint8Array.from(t,o=>o.charCodeAt(0)));e=M(r,r),$e[t]=e}return Lt(M(e,...n))}var Be=t=>t.toRawBytes(!0).slice(1),xe=t=>Q(t,32),ye=t=>H(t,kt),Ht=t=>H(t,Jt),ve=te.ProjectivePoint,zn=(t,n,e)=>ve.BASE.multiplyAndAddUnsafe(t,n,e);function Ee(t){let n=te.utils.normPrivateKeyToScalar(t),e=ve.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:Ht(-n),bytes:Be(e)}}function en(t){$("x",t,Rt,kt);let n=ye(t*t),e=ye(n*t+BigInt(7)),r=Fe(e);r%$t!==tn&&(r=ye(-r));let o=new ve(t,r,Rt);return o.assertValidity(),o}var It=D;function nn(...t){return Ht(It(Ft("BIP0340/challenge",...t)))}function Pn(t){return Ee(t).bytes}function Dn(t,n,e=Vt(32)){let r=C("message",t),{bytes:o,scalar:i}=Ee(n),c=C("auxRand",e,32),f=xe(i^It(Ft("BIP0340/aux",c))),s=Ft("BIP0340/nonce",f,o,r),u=Ht(It(s));if(u===tn)throw new Error("sign failed: k is zero");let{bytes:h,scalar:d}=Ee(u),l=nn(h,o,r),p=new Uint8Array(64);if(p.set(h,0),p.set(xe(Ht(d+l*i)),32),!rn(p,r,o))throw new Error("sign: Invalid signature produced");return p}function rn(t,n,e){let r=C("signature",t,64),o=C("message",n),i=C("publicKey",e,32);try{let c=en(It(i)),f=It(r.subarray(0,32));if(!ft(f,Rt,kt))return!1;let s=It(r.subarray(32,64));if(!ft(s,Rt,Jt))return!1;let u=nn(xe(f),Be(c),o),h=zn(c,s,Ht(-u));return!(!h||!h.hasEvenY()||h.toAffine().x!==f)}catch{return!1}}var Tr={getPublicKey:Pn,sign:Dn,verify:rn,utils:{randomPrivateKey:te.utils.randomPrivateKey,lift_x:en,pointToBytes:Be,numberToBytesBE:Q,bytesToNumberBE:D,taggedHash:Ft,mod:H}},Kn=Xe(dt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Yn=Ye(dt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:dt.create(BigInt("-11"))}),on=Qe(te.ProjectivePoint,t=>{let{x:n,y:e}=Yn(dt.create(t[0]));return Kn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:dt.ORDER,m:1,k:128,expand:"xmd",hash:Lt}),Lr=on.hashToCurve,qr=on.encodeToCurve;export{qr as encodeToCurve,Lr as hashToCurve,Tr as schnorr,te as secp256k1};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=secp256k1-GLIYLLV3.js.map