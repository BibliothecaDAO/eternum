import { Content, IAgentRuntime } from "@ai16z/eliza";
import { Fraction, Percent } from "@uniswap/sdk-core";

import { Account, Contract, RpcProvider } from "starknet";

import { EternumState } from "../types";

export const composeContext = ({ state, template }: { state: EternumState; template: string }) => {
  // @ts-expect-error match isn't working as expected
  return template.replace(/{{\w+}}/g, (match) => {
    return state[match.replace(/{{|}}/g, "")] ?? "";
  });
};

export const validateSettings = (runtime: IAgentRuntime) => {
  const requiredSettings = ["STARKNET_ADDRESS", "STARKNET_PRIVATE_KEY", "STARKNET_RPC_URL"];

  for (const setting of requiredSettings) {
    if (!runtime.getSetting(setting)) {
      return false;
    }
  }

  return true;
};

export const getTokenBalance = async (runtime: IAgentRuntime, tokenAddress: string) => {
  const provider = getStarknetProvider(runtime);

  const { abi: tokenAbi } = await provider.getClassAt(tokenAddress);
  if (tokenAbi === undefined) {
    throw new Error("no abi.");
  }

  const tokenContract = new Contract(tokenAbi, tokenAddress, provider);

  tokenContract.connect(getStarknetAccount(runtime));

  return await tokenContract.balanceOf(tokenAddress);
};

export const getStarknetProvider = (runtime: IAgentRuntime) => {
  return new RpcProvider({
    nodeUrl: runtime.getSetting("STARKNET_RPC_URL"),
  });
};

export const getStarknetAccount = (runtime: IAgentRuntime) => {
  return new Account(
    getStarknetProvider(runtime),
    runtime.getSetting("STARKNET_ADDRESS"),
    runtime.getSetting("STARKNET_PRIVATE_KEY"),
  );
};

export interface TransferContent extends Content {
  tokenAddress: string;
  recipient: string;
  amount: string | number;
}

export function isTransferContent(content: TransferContent): content is TransferContent {
  // Validate types
  const validTypes =
    typeof content.tokenAddress === "string" &&
    typeof content.recipient === "string" &&
    (typeof content.amount === "string" || typeof content.amount === "number");
  if (!validTypes) {
    return false;
  }

  // Validate addresses (must be 32-bytes long with 0x prefix)
  const validAddresses =
    content.tokenAddress.startsWith("0x") &&
    content.tokenAddress.length === 66 &&
    content.recipient.startsWith("0x") &&
    content.recipient.length === 66;

  return validAddresses;
}

export const getPercent = (amount: string | number, decimals: number) => {
  return new Percent(amount, decimals);
};

export const parseFormatedAmount = (amount: string) => amount.replace(/,/g, "");

export const PERCENTAGE_INPUT_PRECISION = 2;

export const parseFormatedPercentage = (percent: string) =>
  new Percent(+percent * 10 ** PERCENTAGE_INPUT_PRECISION, 100 * 10 ** PERCENTAGE_INPUT_PRECISION);

interface ParseCurrencyAmountOptions {
  fixed: number;
  significant?: number;
}

export const formatCurrenyAmount = (amount: Fraction, { fixed, significant = 1 }: ParseCurrencyAmountOptions) => {
  const fixedAmount = amount.toFixed(fixed);
  const significantAmount = amount.toSignificant(significant);

  if (+significantAmount > +fixedAmount) return significantAmount;
  else return +fixedAmount.toString();
};

export const formatPercentage = (percentage: Percent) => {
  const formatedPercentage = +percentage.toFixed(2);
  const exact = percentage.equalTo(new Percent(Math.round(formatedPercentage * 100), 10000));

  return `${exact ? "" : "~"}${formatedPercentage}%`;
};
